---
globs: *.py
alwaysApply: false
---

# Python Testing Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## Test Structure (ENFORCED)

- **pytest Framework**: Use pytest for all testing - MANDATORY
- **Test Discovery**: Follow `test_*.py` and `*_test.py` naming - MANDATORY
- **Test Organization**: Separate unit/, integration/, e2e/ directories - MANDATORY
- **Descriptive Names**: Use `test_functionality_when_condition` format - MANDATORY

## AAA Pattern (ENFORCED)

- **Arrange-Act-Assert**: All tests MUST follow AAA structure - MANDATORY
- **Clear Separation**: Separate setup, execution, and verification - MANDATORY

```python
def test_calculate_total_with_tax():
    # Arrange
    service = PricingService()
    items = [{"price": 10.00, "quantity": 2}]
    tax_rate = 0.08

    # Act
    total = service.calculate_total(items, tax_rate)

    # Assert
    assert total == pytest.approx(27.54, abs=0.01)
```

## Fixtures (ENFORCED)

- **Reusable Fixtures**: Use pytest fixtures for common test setup - MANDATORY
- **Fixture Scope**: Use appropriate fixture scopes (function, class, module) - MANDATORY
- **Async Fixtures**: Use `pytest_asyncio` for async fixtures - MANDATORY

```python
import pytest

@pytest.fixture
def user_service():
    repository = Mock()
    return UserService(repository)

@pytest.fixture
async def async_db_session():
    session = AsyncMock()
    yield session
    # Cleanup
```

## Mocking (ENFORCED)

- **Proper Mock Usage**: Mock external dependencies, not internal logic - MANDATORY
- **AsyncMock**: Use `AsyncMock` for async dependencies - MANDATORY
- **Avoid Over-Mocking**: Don't mock everything - test real behavior when possible - MANDATORY

```python
from unittest.mock import Mock, AsyncMock, patch

def test_payment_processing():
    mock_processor = Mock()
    mock_processor.charge.return_value = {"status": "success"}
    service = PaymentService()
    with patch.object(service, '_get_processor', return_value=mock_processor):
        result = service.process_payment(100.00, "card_123")
    assert result["status"] == "success"
```

## Exception Testing (ENFORCED)

- **Specific Exception Types**: Test for specific exception types, not generic `Exception` - MANDATORY
- **Exception Messages**: Verify exception messages when relevant - MANDATORY
- **Exception Chaining**: Test exception chaining when applicable - MANDATORY

```python
def test_invalid_input_raises_validation_error():
    service = DataProcessor()
    with pytest.raises(ValidationError) as exc_info:
        service.process_data({"value": -1})
    assert "must be positive" in str(exc_info.value)
```

## Test Coverage (ENFORCED - NO EXCEPTIONS)

- **100% Coverage Target**: Aim for 100% test coverage on new code - MANDATORY
- **Minimum 90%**: Maintain at least 90% coverage - MANDATORY (NO EXCEPTIONS)
- **Coverage Reports**: Generate coverage reports in CI - MANDATORY
- **No Excuses**: "Pre-existing condition" is NOT a valid excuse for low coverage
- **Fix Before Commit**: Coverage threshold failures MUST be fixed before commit
- **CI Enforcement**: CI MUST fail if coverage drops below 90%

```toml
[tool.coverage.run]
source = ["src"]
omit = ["*/tests/*", "*/migrations/*"]

[tool.coverage.report]
exclude_lines = ["pragma: no cover", "def __repr__"]
show_missing = true
fail_under = 90
```

## Async Testing (ENFORCED)

- **pytest-asyncio**: Use `@pytest.mark.asyncio` for async tests - MANDATORY
- **Async Fixtures**: Use `pytest_asyncio.fixture` for async fixtures - MANDATORY
- **Proper Awaiting**: Always await async operations in tests - MANDATORY

```python
import pytest

@pytest.mark.asyncio
async def test_async_service():
    service = AsyncDataService()
    mock_repo = AsyncMock()
    mock_repo.fetch_data.return_value = ["item1", "item2"]
    with patch.object(service, '_repository', mock_repo):
        result = await service.get_data()
    assert result == ["item1", "item2"]
```

## Test Data Management (ENFORCED)

- **Test Fixtures**: Use fixtures for test data - MANDATORY
- **Test Factories**: Use factories for complex test data - MANDATORY
- **Avoid Hardcoding**: Don't hardcode test data in test methods - MANDATORY

```python
@pytest.fixture
def sample_user_data():
    return {
        "id": 1,
        "username": "testuser",
        "email": "test@example.com"
    }

class TestDataFactory:
    @staticmethod
    def create_user(overrides=None):
        data = {"username": "testuser", "email": "test@example.com"}
        if overrides:
            data.update(overrides)
        return data
```

## Performance Testing (ENFORCED)

- **Benchmark Tests**: Include performance benchmarks for critical paths - MANDATORY
- **Response Time Assertions**: Assert response time requirements - MANDATORY
- **Load Testing**: Test concurrent request handling - MANDATORY

```python
@pytest.mark.benchmark
def test_algorithm_performance(benchmark):
    test_data = generate_large_test_dataset()
    result = benchmark(lambda: my_algorithm(test_data))
    assert result.stats.mean < 1.0
```

## Test Organization (ENFORCED)

- **Test Classes**: Group related tests in classes - MANDATORY
- **Descriptive Test Names**: Use descriptive test method names - MANDATORY
- **Test Documentation**: Include docstrings for complex tests - MANDATORY

```python
class TestUserServiceCreation:
    def test_create_user_success(self):
        """Test successful user creation."""
        pass

    def test_create_user_fails_with_invalid_email(self):
        """Test user creation fails with invalid email format."""
        pass
```

## Testing Private Functions (ENFORCED - STRICT)

**CRITICAL**: Private functions (prefixed with `_`) MUST NOT be tested directly. This aligns with general testing standards but has Python-specific enforcement.

**Python-Specific Rules:**

- **Private Function Convention**: Functions/methods prefixed with `_` are private implementation details - MANDATORY
- **Pyright Enforcement**: `reportPrivateUsage` errors indicate private function access - MANDATORY to fix
- **Type Checker Suppressions FORBIDDEN**: Using `# type: ignore[reportPrivateUsage]` to test private functions is STRICTLY FORBIDDEN
- **Test Through Public API**: All private function behavior MUST be tested through public interface - MANDATORY

**FORBIDDEN (Python-Specific):**

```python
# ❌ FORBIDDEN - Direct import of private function
from mymodule import _calculate_tax  # type: ignore[reportPrivateUsage]

def test_calculate_tax():
    result = _calculate_tax(100.00)  # BLOCKED
    assert result == 8.00
```

```python
# ❌ FORBIDDEN - Type ignore to suppress private usage
from mymodule import _validate_input  # type: ignore[reportPrivateUsage]

def test_validate_input():
    assert _validate_input("test")  # BLOCKED
```

**REQUIRED (Python-Specific):**

```python
# ✅ REQUIRED - Test through public interface
from mymodule import PricingService

def test_calculate_total_includes_tax():
    """Test tax calculation through public API."""
    service = PricingService()
    # Tax calculation is private, but we test it through public method
    total = service.calculate_total_with_tax(100.00)
    assert total == 108.00  # Verifies _calculate_tax indirectly
```

```python
# ✅ REQUIRED - Extract private function to public if needed
# If _validate_input needs direct testing, make it public:
# def validate_input(...) instead of def _validate_input(...)
# OR extract to separate module for testing
```

**Pyright Configuration:**

- **reportPrivateUsage**: Enabled by default - MANDATORY
- **No Suppressions**: Do NOT add `# type: ignore[reportPrivateUsage]` to test files - FORBIDDEN
- **Fix Violations**: All `reportPrivateUsage` errors in test files MUST be fixed - MANDATORY

**Refactoring Strategy:**

1. **If private function needs testing**: Make it public (remove `_` prefix) OR extract to separate module
2. **If behavior is complex**: Test through public API that uses the private function
3. **If testing is difficult**: Refactor to improve testability (dependency injection, smaller functions)

**Enforcement:**

- **Type Checker**: Pyright MUST report zero `reportPrivateUsage` errors in test files
- **CI Validation**: CI MUST fail if test files import private functions
- **Code Review**: All private function imports in tests MUST be rejected

## Violations (BLOCKED)

- ❌ Tests without clear AAA structure
- ❌ Missing test coverage for new/updated functionality
- ❌ Tests that don't verify behavior or state changes
- ❌ Over-mocking that removes test value
- ❌ Tests without descriptive names
- ❌ Async tests without proper pytest-asyncio usage
- ❌ Exception tests that don't specify exception types
- ❌ Tests that only cover happy paths
- ❌ Performance tests missing timing assertions
- ❌ Test data hardcoded in test methods
- ❌ Missing fixtures for common test setup
- ❌ Tests that modify shared state without cleanup
- ❌ Importing private functions (prefixed with `_`) in test files
- ❌ Using `# type: ignore[reportPrivateUsage]` to test private functions
- ❌ Direct testing of private implementation details

## Enforcement

- **pytest Configuration**: Proper pytest.ini configuration in CI
- **Coverage Requirements**: Minimum 90% coverage (MANDATORY - NO EXCEPTIONS)
- **Test Execution**: All tests must pass in CI
- **Performance Benchmarks**: Performance tests included in CI pipeline
- **Code Review**: Test quality review required for all PRs
- **NO exceptions**: All testing standard violations must be fixed before merge
- **Coverage Excuses Forbidden**: "Pre-existing condition", "technical debt", or "will fix later" are NOT valid excuses
