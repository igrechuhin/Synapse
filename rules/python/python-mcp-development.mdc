---
globs: *.py
alwaysApply: false
---

# Python MCP Development Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## MCP Server Architecture (ENFORCED)

### Server Structure

```python
# ✅ REQUIRED
class DocMCPServer:
    def __init__(self):
        self.server = Server("server-name")
        self.config = None

    async def initialize_async(self):
        """Async initialization."""
        pass

    @self.server.list_resources()
    async def handle_list_resources(self):
        return []

# ❌ PROHIBITED
class BadMCPServer:
    @self.server.list_resources  # Missing ()
    async def handler(self):  # Extra self parameter
        pass
```

### Handler Registration

- **Register on MCP Server instance**: Use `@self.server.list_resources()` - MANDATORY
- **Proper return types**: Return proper MCP response formats - MANDATORY
- **Type hints**: All handlers MUST have complete type hints - MANDATORY

### Project Root Resolution (CRITICAL MANDATORY)

- **ALL Cortex MCP tools resolve project root internally** - MANDATORY, NO EXCEPTIONS
- **NEVER accept `project_root` as a parameter** - STRICTLY FORBIDDEN
- **Project root is resolved automatically** via the `@ensure_usage_context` decorator using `resolve_project_root_async(None, ctx)`
- **Tools access project root internally** by calling `resolve_project_root_async(None, ctx)` where `ctx` is the MCP context injected by FastMCP
- **External callers MUST NOT pass `project_root`** - tools will raise `TypeError` if it's passed (enforces migration away from legacy patterns)
- **This ensures consistency**: All tools use the same root resolution logic, preventing path resolution errors

```python
# ✅ CORRECT - Project root resolved internally
from cortex.core.project_root_resolver import resolve_project_root_async
from cortex.core.context_logging import MCPContext

@mcp.tool(annotations=read_only_annotations("Get Stats"))
@ensure_usage_context
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_FAST)
async def get_stats(ctx: MCPContext | None = None) -> str:
    """Read-only tool that retrieves statistics."""
    root = await resolve_project_root_async(None, ctx)
    # Use root internally...
    ...

# ❌ PROHIBITED - Accepting project_root as parameter
@mcp.tool(annotations=read_only_annotations("Get Stats"))
@ensure_usage_context
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_FAST)
async def get_stats(project_root: str | None = None) -> str:  # BLOCKED
    """Tools must NOT accept project_root."""
    ...
```

### MCP Tool Required Decorator Stack (MANDATORY)

- **Every `@mcp.tool()` MUST use the full stack in order** - MANDATORY, NO EXCEPTIONS:
  1. `@mcp.tool(annotations=...)` — with appropriate annotations from `cortex.core.mcp_annotations`
  2. `@ensure_usage_context` — enables usage recording for analytics AND resolves project root internally
  3. `@mcp_tool_wrapper(timeout=...)` — timeout and stability
- **Prevents session hangs**: Long-running or blocking tool execution is bounded; the event loop stays responsive
- **Use timeout constants** from `cortex.core.constants`: `MCP_TOOL_TIMEOUT_FAST` (60s), `MCP_TOOL_TIMEOUT_MEDIUM` (120s), `MCP_TOOL_TIMEOUT_COMPLEX` (300s), `MCP_TOOL_TIMEOUT_VERY_COMPLEX` (600s), `MCP_TOOL_TIMEOUT_EXTERNAL` (120s)
- **CI enforcement**: `test_every_mcp_tool_has_required_wrappers` fails if any tool in `src/cortex/tools` lacks this exact stack

### MCP Tool Annotations (MANDATORY)

- **Every `@mcp.tool()` MUST include `annotations=...`** - MANDATORY, NO EXCEPTIONS
- **Use annotation helpers** from `cortex.core.mcp_annotations`:
  - `read_only_annotations(title)` — for tools that only read data (queries, stats, health checks)
  - `safe_write_annotations(title)` — for tools that create/update data non-destructively
  - `destructive_annotations(title)` — for tools that delete or overwrite data irreversibly
  - `external_annotations(title, read_only=...)` — for tools that interact with external systems (subprocesses, network)
- **Annotations communicate tool behavior to MCP clients** (Claude, ChatGPT, etc.) for better UX:
  - `readOnlyHint=True` allows clients to skip confirmation prompts for safe operations
  - `destructiveHint=True` signals irreversible changes requiring user confirmation
  - `openWorldHint=True` indicates external system interactions
  - `idempotentHint=True` indicates repeated calls have no additional effect

```python
# ✅ REQUIRED - Full stack with annotations
from cortex.core.constants import MCP_TOOL_TIMEOUT_MEDIUM
from cortex.core.mcp_annotations import read_only_annotations, safe_write_annotations
from cortex.core.mcp_stability import ensure_usage_context, mcp_tool_wrapper
from cortex.server import mcp

@mcp.tool(annotations=read_only_annotations("Get Stats"))
@ensure_usage_context
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_FAST)
async def get_stats() -> str:
    """Read-only tool that retrieves statistics.
    
    Note: Project root is resolved internally via @ensure_usage_context decorator.
    Tools should NEVER accept project_root as a parameter.
    """
    ...

@mcp.tool(annotations=safe_write_annotations("Update Config"))
@ensure_usage_context
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_MEDIUM)
async def update_config(key: str, value: str) -> str:
    """Safe write tool that updates configuration."""
    ...

# ❌ PROHIBITED - Missing annotations
@mcp.tool()  # BLOCKED - missing annotations parameter
@ensure_usage_context
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_MEDIUM)
async def my_tool(...) -> str:
    ...

# ❌ PROHIBITED - Missing required stack
@mcp.tool(annotations=read_only_annotations("My Tool"))
@mcp_tool_wrapper(timeout=MCP_TOOL_TIMEOUT_MEDIUM)  # BLOCKED - missing @ensure_usage_context
async def my_tool(...) -> str:
    ...

# ❌ PROHIBITED - Missing timeout wrapper
@mcp.tool(annotations=read_only_annotations("My Tool"))
async def my_tool(...) -> str:  # BLOCKED - will hang on long runs, no usage tracking
    ...
```

- **Choosing annotation helper**:
  - `read_only_annotations`: Stats, queries, health checks, version history, structure info
  - `safe_write_annotations`: File creation/update, config changes, non-destructive modifications
  - `destructive_annotations`: Rollback, delete, overwrite operations
  - `external_annotations`: Pre-commit checks, subprocess execution, network calls
- **Choosing timeout**: Use FAST for health/stats/queries; MEDIUM for single-file or config; COMPLEX for analysis/multi-file; VERY_COMPLEX for full tests or large refactors; EXTERNAL for git/network

## stdio Communication (ENFORCED)

### Context Manager Usage

```python
# ✅ REQUIRED
async def main():
    server = DocMCPServer()
    await server.initialize_async()
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.server.run(read_stream, write_stream, server.server.create_initialization_options())

# ❌ PROHIBITED
async with mcp.server.stdio.stdio_server(server.server):  # Causes async iterator error
    pass
```

### Main Function Pattern

```python
# ✅ REQUIRED - Synchronous main
def main():
    async def run_server():
        server = DocMCPServer()
        await server.initialize_async()
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await server.server.run(read_stream, write_stream, server.server.create_initialization_options())
    asyncio.run(run_server())

# ❌ PROHIBITED - Async main
async def bad_main():  # Causes "coroutine was never awaited"
    pass
```

## Typed MCP Boundaries (STRICT MANDATORY)

- **All public MCP handlers MUST have fully explicit parameter and return types** - STRICT MANDATORY
- **Pydantic 2 Models First**: MCP tool return types MUST use Pydantic `BaseModel` - STRICT MANDATORY, NO EXCEPTIONS
- **Use Pydantic 2 API**: `model_validate()`, `model_dump()`, `ConfigDict` - MANDATORY
- **NEVER Use `Any`**: `Any` type is STRICTLY FORBIDDEN in MCP handlers - STRICT MANDATORY
- **NEVER Use Untyped Collections**: Untyped `dict`, `list`, `tuple`, `set` are STRICTLY FORBIDDEN - STRICT MANDATORY
- **JSON-like inputs**: MUST use Pydantic `BaseModel` (preferred) or `TypedDict` - STRICT MANDATORY
- See `python-pydantic-standards.mdc` for comprehensive Pydantic 2 guidelines

```python
from pydantic import BaseModel, Field, ConfigDict
from typing import Literal

class OptimizeContextRequest(BaseModel):
    """Request model for context optimization."""
    model_config = ConfigDict(str_strip_whitespace=True)
    
    memory_bank_root: str = Field(min_length=1, description="Path to memory bank")
    max_tokens: int = Field(gt=0, description="Maximum tokens to include")
    strategy: Literal["relevance", "recency", "hybrid"] = "relevance"

class OptimizeContextResult(BaseModel):
    """Result model for context optimization."""
    status: Literal["success", "error"]
    selected_files: list[str] = Field(default_factory=list)
    total_tokens: int = Field(ge=0)
    error: str | None = None

@mcp.tool()
async def load_context(request: LoadContextRequest) -> LoadContextResult:
    result = _load_context_impl(
        root=request.memory_bank_root,
        max_tokens=request.max_tokens,
        strategy=request.strategy,
    )
    return LoadContextResult(
        status="success",
        selected_files=result.selected_files,
        total_tokens=result.total_tokens,
    )
```

### Pure Helpers Inside Handlers (ENFORCED)

- **MCP handlers MUST stay thin orchestrators**: Parse/validate inputs, delegate to pure helpers, map results
- **Core logic in pure helpers**: Small, pure helpers that are easy to test and refactor

```python
def _load_context_impl(root: str, max_tokens: int, strategy: str) -> LoadContextResult:
    """Pure helper (no I/O, fully typed)."""
    # ... pure computation ...
    return LoadContextResult(selected_files=[], total_tokens=0)
```

### Pydantic Models for MCP Tool Return Types (STRICT MANDATORY)

**CRITICAL**: All MCP tool return types MUST use Pydantic `BaseModel` instead of `TypedDict`, `dict[str, object]`, untyped `dict`, `list`, or `Any`. ZERO TOLERANCE.

**Pattern:**

1. Define Pydantic models at module level
2. Use Pydantic models in handler return types
3. Use `Literal` or **prefer `class X(str, Enum)`** for status/fixed-set fields (see python-coding-standards: "Fixed Sets of Values: Prefer Enums"); at the MCP boundary accept `str`, validate to enum inside the handler, use `.value` when writing to JSON/dict
4. Use optional fields with `None` defaults
5. Use nested Pydantic models for complex structures
6. Return models directly (do NOT convert to dicts)

```python
# ✅ CORRECT
class ValidationResult(BaseModel):
    status: Literal["success", "error"]
    valid: bool
    errors: list[ValidationError]
    score: int
    error: str | None = None

@mcp.tool()
async def validate_memory_bank(...) -> ValidationResult:
    return ValidationResult(status="success", valid=True, errors=[], score=100)

# ❌ PROHIBITED
@mcp.tool()
async def validate_memory_bank(...) -> dict[str, object]:  # BLOCKED
    return {"status": "success"}  # BLOCKED
```

**FORBIDDEN:**

- ❌ Using `dict[str, object]` for MCP tool return types (STRICTLY FORBIDDEN)
- ❌ Using untyped `dict`, `list`, `tuple`, `set` (STRICTLY FORBIDDEN)
- ❌ Using `Any` type (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts (STRICTLY FORBIDDEN)
- ❌ Using TypedDict for new MCP tools (STRICTLY FORBIDDEN - Pydantic required)
- ❌ Missing `status` field with `Literal` type (STRICTLY FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Missing `Field()` constraints for user input validation (STRICTLY FORBIDDEN)

## Common MCP Errors

### Error: "coroutine 'main' was never awaited"

**Fix**: Make main function synchronous, run async code internally

### Error: "async for requires an object with **aiter** method"

**Fix**: Call `stdio_server()` without arguments

### Error: "'Server' object has no attribute 'initialize'"

**Fix**: Register handlers on `self.server` (MCP Server instance), not wrapper class

## Tool Naming (MANDATORY)

- Use snake_case verbs plus domain nouns (e.g., `search_docs`, `find_component`)
- Start with action verb; avoid bare nouns
- Keep names to three segments or fewer
- Document tool names, schemas, and examples

## Violations (BLOCKED)

- ❌ **MCP tool accepting project_root parameter**: Tools MUST resolve project root internally via `@ensure_usage_context`; accepting `project_root` as a parameter is STRICTLY FORBIDDEN
- ❌ **MCP tool without annotations**: Every `@mcp.tool()` MUST include `annotations=...` parameter using helpers from `cortex.core.mcp_annotations` (STRICTLY FORBIDDEN)
- ❌ **MCP tool without full decorator stack**: Every `@mcp.tool()` MUST have `@ensure_usage_context` then `@mcp_tool_wrapper(timeout=...)` in that order (STRICTLY FORBIDDEN)
- ❌ Async main functions in script entry points
- ❌ Passing server objects to stdio_server()
- ❌ Registering MCP handlers on wrapper classes instead of MCP Server instances
- ❌ Using `dict[str, object]` for MCP tool return types (STRICTLY FORBIDDEN)
- ❌ Using untyped `dict`, `list`, `tuple`, `set` in MCP tools (STRICTLY FORBIDDEN)
- ❌ Using `Any` type in MCP tools (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts before returning (STRICTLY FORBIDDEN)
- ❌ Missing Pydantic models for structured return types (STRICTLY FORBIDDEN)
- ❌ Missing `status: Literal["success", "error"]` field (STRICTLY FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Missing `Field()` constraints for user input (STRICTLY FORBIDDEN)
- ❌ Using `regex` parameter instead of `pattern` in Field (STRICTLY FORBIDDEN)
- ❌ Missing `@classmethod` decorator on `@field_validator` (STRICTLY FORBIDDEN)

## Enforcement

- **MCP Protocol Compliance**: Automated tests verify MCP message formats
- **Async Error Prevention**: Static analysis flags potential async iterator misuse
- **Handler Registration**: Code review ensures handlers registered on correct objects
- **stdio Communication**: Tests verify correct stdio_server usage
- **NO exceptions**: All MCP development violations must be fixed before merge
