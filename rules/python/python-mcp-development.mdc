---
globs: *.py
alwaysApply: false
---

# Python MCP Development Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## MCP Server Architecture (ENFORCED)

### Server Structure

```python
# ✅ REQUIRED
class DocMCPServer:
    def __init__(self):
        self.server = Server("server-name")
        self.config = None

    async def initialize_async(self):
        """Async initialization."""
        pass

    @self.server.list_resources()
    async def handle_list_resources(self):
        return []

# ❌ PROHIBITED
class BadMCPServer:
    @self.server.list_resources  # Missing ()
    async def handler(self):  # Extra self parameter
        pass
```

### Handler Registration

- **Register on MCP Server instance**: Use `@self.server.list_resources()` - MANDATORY
- **Proper return types**: Return proper MCP response formats - MANDATORY
- **Type hints**: All handlers MUST have complete type hints - MANDATORY

## stdio Communication (ENFORCED)

### Context Manager Usage

```python
# ✅ REQUIRED
async def main():
    server = DocMCPServer()
    await server.initialize_async()
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.server.run(read_stream, write_stream, server.server.create_initialization_options())

# ❌ PROHIBITED
async with mcp.server.stdio.stdio_server(server.server):  # Causes async iterator error
    pass
```

### Main Function Pattern

```python
# ✅ REQUIRED - Synchronous main
def main():
    async def run_server():
        server = DocMCPServer()
        await server.initialize_async()
        async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
            await server.server.run(read_stream, write_stream, server.server.create_initialization_options())
    asyncio.run(run_server())

# ❌ PROHIBITED - Async main
async def bad_main():  # Causes "coroutine was never awaited"
    pass
```

## Typed MCP Boundaries (STRICT MANDATORY)

- **All public MCP handlers MUST have fully explicit parameter and return types** - STRICT MANDATORY
- **Pydantic 2 Models First**: MCP tool return types MUST use Pydantic `BaseModel` - STRICT MANDATORY, NO EXCEPTIONS
- **Use Pydantic 2 API**: `model_validate()`, `model_dump()`, `ConfigDict` - MANDATORY
- **NEVER Use `Any`**: `Any` type is STRICTLY FORBIDDEN in MCP handlers - STRICT MANDATORY
- **NEVER Use Untyped Collections**: Untyped `dict`, `list`, `tuple`, `set` are STRICTLY FORBIDDEN - STRICT MANDATORY
- **JSON-like inputs**: MUST use Pydantic `BaseModel` (preferred) or `TypedDict` - STRICT MANDATORY
- See `python-pydantic-standards.mdc` for comprehensive Pydantic 2 guidelines

```python
from pydantic import BaseModel, Field, ConfigDict
from typing import Literal

class OptimizeContextRequest(BaseModel):
    """Request model for context optimization."""
    model_config = ConfigDict(str_strip_whitespace=True)
    
    memory_bank_root: str = Field(min_length=1, description="Path to memory bank")
    max_tokens: int = Field(gt=0, description="Maximum tokens to include")
    strategy: Literal["relevance", "recency", "hybrid"] = "relevance"

class OptimizeContextResult(BaseModel):
    """Result model for context optimization."""
    status: Literal["success", "error"]
    selected_files: list[str] = Field(default_factory=list)
    total_tokens: int = Field(ge=0)
    error: str | None = None

@mcp.tool()
async def load_context(request: LoadContextRequest) -> LoadContextResult:
    result = _load_context_impl(
        root=request.memory_bank_root,
        max_tokens=request.max_tokens,
        strategy=request.strategy,
    )
    return LoadContextResult(
        status="success",
        selected_files=result.selected_files,
        total_tokens=result.total_tokens,
    )
```

### Pure Helpers Inside Handlers (ENFORCED)

- **MCP handlers MUST stay thin orchestrators**: Parse/validate inputs, delegate to pure helpers, map results
- **Core logic in pure helpers**: Small, pure helpers that are easy to test and refactor

```python
def _load_context_impl(root: str, max_tokens: int, strategy: str) -> LoadContextResult:
    """Pure helper (no I/O, fully typed)."""
    # ... pure computation ...
    return LoadContextResult(selected_files=[], total_tokens=0)
```

### Pydantic Models for MCP Tool Return Types (STRICT MANDATORY)

**CRITICAL**: All MCP tool return types MUST use Pydantic `BaseModel` instead of `TypedDict`, `dict[str, object]`, untyped `dict`, `list`, or `Any`. ZERO TOLERANCE.

**Pattern:**
1. Define Pydantic models at module level
2. Use Pydantic models in handler return types
3. Use `Literal` types for status/enum fields
4. Use optional fields with `None` defaults
5. Use nested Pydantic models for complex structures
6. Return models directly (do NOT convert to dicts)

```python
# ✅ CORRECT
class ValidationResult(BaseModel):
    status: Literal["success", "error"]
    valid: bool
    errors: list[ValidationError]
    score: int
    error: str | None = None

@mcp.tool()
async def validate_memory_bank(...) -> ValidationResult:
    return ValidationResult(status="success", valid=True, errors=[], score=100)

# ❌ PROHIBITED
@mcp.tool()
async def validate_memory_bank(...) -> dict[str, object]:  # BLOCKED
    return {"status": "success"}  # BLOCKED
```

**FORBIDDEN:**
- ❌ Using `dict[str, object]` for MCP tool return types (STRICTLY FORBIDDEN)
- ❌ Using untyped `dict`, `list`, `tuple`, `set` (STRICTLY FORBIDDEN)
- ❌ Using `Any` type (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts (STRICTLY FORBIDDEN)
- ❌ Using TypedDict for new MCP tools (STRICTLY FORBIDDEN - Pydantic required)
- ❌ Missing `status` field with `Literal` type (STRICTLY FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Missing `Field()` constraints for user input validation (STRICTLY FORBIDDEN)

## Common MCP Errors

### Error: "coroutine 'main' was never awaited"
**Fix**: Make main function synchronous, run async code internally

### Error: "async for requires an object with __aiter__ method"
**Fix**: Call `stdio_server()` without arguments

### Error: "'Server' object has no attribute 'initialize'"
**Fix**: Register handlers on `self.server` (MCP Server instance), not wrapper class

## Tool Naming (MANDATORY)

- Use snake_case verbs plus domain nouns (e.g., `search_docs`, `find_component`)
- Start with action verb; avoid bare nouns
- Keep names to three segments or fewer
- Document tool names, schemas, and examples

## Violations (BLOCKED)

- ❌ Async main functions in script entry points
- ❌ Passing server objects to stdio_server()
- ❌ Registering MCP handlers on wrapper classes instead of MCP Server instances
- ❌ Using `dict[str, object]` for MCP tool return types (STRICTLY FORBIDDEN)
- ❌ Using untyped `dict`, `list`, `tuple`, `set` in MCP tools (STRICTLY FORBIDDEN)
- ❌ Using `Any` type in MCP tools (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts before returning (STRICTLY FORBIDDEN)
- ❌ Missing Pydantic models for structured return types (STRICTLY FORBIDDEN)
- ❌ Missing `status: Literal["success", "error"]` field (STRICTLY FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Missing `Field()` constraints for user input (STRICTLY FORBIDDEN)
- ❌ Using `regex` parameter instead of `pattern` in Field (STRICTLY FORBIDDEN)
- ❌ Missing `@classmethod` decorator on `@field_validator` (STRICTLY FORBIDDEN)

## Enforcement

- **MCP Protocol Compliance**: Automated tests verify MCP message formats
- **Async Error Prevention**: Static analysis flags potential async iterator misuse
- **Handler Registration**: Code review ensures handlers registered on correct objects
- **stdio Communication**: Tests verify correct stdio_server usage
- **NO exceptions**: All MCP development violations must be fixed before merge
