---
globs: *.py
alwaysApply: false
---

# Python Security Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## Input Validation (ENFORCED)

- **Comprehensive Input Validation**: Validate all external inputs - MANDATORY
- **Pydantic Models**: Use Pydantic `BaseModel` with validators for input validation - MANDATORY
- **Sanitization**: Sanitize all user inputs before processing - MANDATORY

```python
from pydantic import BaseModel, Field, validator

class UserInput(BaseModel):
username: str = Field(..., min_length=3, max_length=50)
email: str = Field(..., regex=r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$')
age: int | None = Field(None, ge=0, le=150)

@validator('username')
def validate_username(cls, v):
    if not re.match(r'^[a-zA-Z0-9_-]+$', v):
        raise ValueError('Username contains invalid characters')
    return v
```

## SQL Injection Prevention (ENFORCED)

- **Parameterized Queries**: ALWAYS use parameterized queries - MANDATORY
- **NEVER String Interpolation**: String interpolation in SQL is STRICTLY FORBIDDEN

```python
# ✅ REQUIRED
async def get_user_safe(session: AsyncSession, user_id: int):
    result = await session.execute(
        text("SELECT * FROM users WHERE id = :user_id"),
        {"user_id": user_id}
    )
    return result.fetchone()

# ❌ PROHIBITED
query = f"SELECT * FROM users WHERE id = '{user_id}'"  # VULNERABLE
```

## Authentication & Authorization (ENFORCED)

### Secure Password Handling

- **PBKDF2**: Use PBKDF2 with SHA-256, 100,000+ iterations - MANDATORY
- **Secure Random Salts**: Use `secrets.token_bytes()` for salts - MANDATORY
- **Timing-Safe Comparison**: Use `secrets.compare_digest()` - MANDATORY

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import secrets, base64

    def hash_password(password: str) -> str:
    salt = secrets.token_bytes(32)
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100_000)
        key = kdf.derive(password.encode())
    return base64.b64encode(salt + key).decode()

    def verify_password(password: str, hashed: str) -> bool:
    hash_bytes = base64.b64decode(hashed.encode())
    salt, stored_key = hash_bytes[:32], hash_bytes[32:]
    kdf = PBKDF2HMAC(algorithm=hashes.SHA256(), length=32, salt=salt, iterations=100_000)
            key = kdf.derive(password.encode())
            return secrets.compare_digest(key, stored_key)
```

**FORBIDDEN:**
- ❌ MD5, SHA1, or other weak hashing algorithms
- ❌ Plain text password storage
- ❌ Timing attack vulnerable comparisons (`==` for passwords)

### JWT Token Security

- **Strong Secrets**: Secret keys must be at least 32 characters - MANDATORY
- **Expiration**: All tokens MUST have expiration - MANDATORY
- **Token Type**: Include token type in payload - MANDATORY
- **Algorithm Restriction**: Specify allowed algorithms explicitly - MANDATORY

```python
import jwt
from datetime import datetime, timedelta, timezone

def create_access_token(data: dict[str, Any], secret: str) -> str:
        to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=15)
        to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, secret, algorithm="HS256")

def verify_token(token: str, secret: str) -> dict[str, Any] | None:
    try:
        payload = jwt.decode(token, secret, algorithms=["HS256"])
            if payload.get("type") not in ["access", "refresh"]:
                return None
            return payload
    except (jwt.ExpiredSignatureError, jwt.InvalidTokenError):
            return None
```

## Data Protection (ENFORCED)

### Sensitive Data Handling

- **Encryption**: Encrypt sensitive data at rest - MANDATORY
- **Environment Variables**: Store secrets in environment variables, NEVER in code - MANDATORY
- **Secure Logging**: NEVER log sensitive data (passwords, tokens, keys) - MANDATORY

```python
from cryptography.fernet import Fernet
import os

class DataEncryption:
    def __init__(self):
        key = os.getenv('ENCRYPTION_KEY')
        if not key or len(key) < 32:
            raise ValueError("ENCRYPTION_KEY must be at least 32 characters")
        self.fernet = Fernet(key.encode())

    def encrypt(self, data: str) -> str:
        return self.fernet.encrypt(data.encode()).decode()

    def decrypt(self, encrypted: str) -> str:
        return self.fernet.decrypt(encrypted.encode()).decode()
```

### Secure Logging

- **Sanitize Sensitive Data**: Remove passwords, tokens, keys from logs - MANDATORY
- **Pattern Matching**: Use regex to detect and sanitize sensitive patterns - MANDATORY

```python
import re, logging

class SecureLogger:
    SENSITIVE_PATTERNS = [
        (re.compile(r'password["\']?\s*:\s*["\']([^"\']+)["\']'), 'password: "***"'),
        (re.compile(r'api_key["\']?\s*:\s*["\']([^"\']+)["\']'), 'api_key: "***"'),
        (re.compile(r'token["\']?\s*:\s*["\']([^"\']+)["\']'), 'token: "***"'),
    ]

    def _sanitize_message(self, message: str) -> str:
        sanitized = message
        for pattern, replacement in self.SENSITIVE_PATTERNS:
            sanitized = pattern.sub(replacement, sanitized)
        return sanitized
```

## Network Security (ENFORCED)

### Secure HTTP Client

- **TLS 1.2+**: Require TLS 1.2 or higher - MANDATORY
- **Certificate Verification**: Always verify certificates - MANDATORY
- **Timeouts**: Set appropriate timeouts - MANDATORY
- **Secure Headers**: Include security headers in requests - MANDATORY

```python
import aiohttp, ssl
from aiohttp import ClientTimeout

ssl_context = ssl.create_default_context()
ssl_context.check_hostname = True
ssl_context.verify_mode = ssl.CERT_REQUIRED
ssl_context.minimum_version = ssl.TLSVersion.TLSv1_2

timeout = ClientTimeout(total=30, connect=10, sock_read=10)

        async with aiohttp.ClientSession(
    connector=aiohttp.TCPConnector(ssl=ssl_context),
    timeout=timeout
        ) as session:
            async with session.get(url) as response:
        return await response.json()
```

### URL Validation

- **Allowed Schemes**: Only allow `http` and `https` - MANDATORY
- **Domain Whitelisting**: Validate against allowed domains when applicable - MANDATORY
- **Path Traversal Prevention**: Block `..` and dangerous paths - MANDATORY

```python
from urllib.parse import urlparse

    ALLOWED_SCHEMES = {'http', 'https'}
DANGEROUS_PATTERNS = [r'\.\.', r'localhost', r'127\.0\.0\.1']

def validate_url(url: str, allowed_domains: list[str] | None = None) -> bool:
            parsed = urlparse(url)
    if parsed.scheme not in ALLOWED_SCHEMES:
                return False
    if any(re.search(pattern, url.lower()) for pattern in DANGEROUS_PATTERNS):
                    return False
            if allowed_domains:
                domain = parsed.netloc.lower()
                if not any(domain.endswith(allowed) for allowed in allowed_domains):
                    return False
            return True
```

## Secure Configuration (ENFORCED)

### Environment Variables

- **Required Variables**: Validate all required environment variables on startup - MANDATORY
- **Secret Validation**: Validate secret key length and format - MANDATORY
- **File Permissions**: Check .env file permissions (not world-readable) - MANDATORY

```python
import os
from pathlib import Path

REQUIRED_VARS = {'DATABASE_URL', 'SECRET_KEY', 'ENCRYPTION_KEY'}
SENSITIVE_VARS = {'SECRET_KEY', 'ENCRYPTION_KEY', 'API_KEY', 'JWT_SECRET'}

def validate_environment() -> dict[str, str]:
    missing = []
    for var in REQUIRED_VARS:
        value = os.getenv(var)
            if not value:
            missing.append(var)
        elif var == 'SECRET_KEY' and len(value) < 32:
            raise ValueError(f"{var} must be at least 32 characters")
    if missing:
        raise ValueError(f"Missing required variables: {missing}")
    return {name: os.getenv(name) for name in REQUIRED_VARS}
```

## File System Security (ENFORCED)

- **Path Validation**: Validate all file paths to prevent directory traversal - MANDATORY
- **Base Directory Restriction**: Restrict file operations to allowed directories - MANDATORY
- **File Size Limits**: Enforce maximum file sizes - MANDATORY
- **Secure Permissions**: Set appropriate file permissions (0o600 for sensitive files) - MANDATORY

```python
from pathlib import Path

def validate_file_path(file_path: Path, base_dir: Path) -> bool:
    resolved = file_path.resolve()
    if not resolved.is_relative_to(base_dir.resolve()):
        return False
            if '..' in file_path.parts:
                return False
            return True

def secure_write_file(path: Path, content: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, 'w') as f:
        f.write(content)
    path.chmod(0o600)  # Owner read/write only
```

## Cryptography (ENFORCED)

- **Secure Random**: Use `secrets` module, NEVER `random` for security-sensitive operations - MANDATORY
- **Strong Algorithms**: Use PBKDF2, Fernet, or other strong algorithms - MANDATORY

```python
import secrets

    def generate_token(length: int = 32) -> str:
        return secrets.token_urlsafe(length)

    def generate_session_id() -> str:
    return secrets.token_hex(32)
```

**FORBIDDEN:**
- ❌ `random` module for security-sensitive operations
- ❌ Weak algorithms (MD5, SHA1, DES)
- ❌ Predictable random generation

## Security Headers (ENFORCED)

- **X-Frame-Options**: Set to `DENY` - MANDATORY
- **X-Content-Type-Options**: Set to `nosniff` - MANDATORY
- **Strict-Transport-Security**: Include HSTS header - MANDATORY
- **Content-Security-Policy**: Configure CSP - MANDATORY

```python
SECURITY_HEADERS = {
            'X-Frame-Options': 'DENY',
            'X-Content-Type-Options': 'nosniff',
            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': "default-src 'self'",
}
```

## Rate Limiting (ENFORCED)

- **Rate Limiting**: Implement rate limiting on all public endpoints - MANDATORY
- **Token Bucket or Sliding Window**: Use appropriate rate limiting algorithm - MANDATORY

```python
from collections import defaultdict, deque
import time

class RateLimiter:
    def __init__(self, window_size: int, max_requests: int):
        self.window_size = window_size
        self.max_requests = max_requests
        self.requests: dict[str, deque] = defaultdict(deque)

    def is_allowed(self, key: str) -> bool:
        now = time.time()
        queue = self.requests[key]
        while queue and queue[0] < now - self.window_size:
            queue.popleft()
        if len(queue) < self.max_requests:
            queue.append(now)
            return True
        return False
```

## Security Testing (ENFORCED)

- **SQL Injection Tests**: Test all database queries for SQL injection - MANDATORY
- **XSS Tests**: Test all user input for XSS vulnerabilities - MANDATORY
- **Input Validation Tests**: Comprehensive input validation testing - MANDATORY
- **Path Traversal Tests**: Test file operations for path traversal - MANDATORY

```python
import pytest

def test_sql_injection_prevention(db_session):
    malicious_inputs = ["'; DROP TABLE users; --", "' OR '1'='1"]
    for malicious_input in malicious_inputs:
        with pytest.raises(ValueError):
            get_user_by_username(db_session, malicious_input)

def test_path_traversal_prevention(secure_file_manager):
    dangerous_paths = ["../../../etc/passwd", "..\\..\\..\\windows\\system32"]
    for dangerous_path in dangerous_paths:
        assert not secure_file_manager.validate_path(Path(dangerous_path))
```

## Violations (BLOCKED)

- ❌ SQL injection vulnerabilities
- ❌ Weak password hashing (MD5, SHA1)
- ❌ Plain text password storage
- ❌ Logging sensitive information
- ❌ Missing input validation
- ❌ Insecure HTTP configurations
- ❌ Missing security headers
- ❌ No rate limiting protection
- ❌ Insecure random number generation
- ❌ Directory traversal vulnerabilities
- ❌ Missing HTTPS enforcement
- ❌ No CSRF protection
- ❌ Timing attack vulnerabilities
- ❌ Use of deprecated cryptographic functions
- ❌ Hardcoded secrets in code

## Enforcement

- **Dependency Scanning**: Automated vulnerability scanning in CI
- **Static Security Analysis**: Bandit, Safety, and other security scanners
- **Security Testing**: Comprehensive security test suite
- **Security Headers Check**: Automated validation of security headers
- **Input Validation Testing**: Fuzzing and boundary testing
- **NO exceptions**: All security violations must be fixed before merge
