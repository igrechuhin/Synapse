---
globs: *.py
alwaysApply: false
---

# Python Coding Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## Core Principles

- **PEP 8 Compliance**: MANDATORY
- **Readability First**: Code must be immediately understandable - MANDATORY
- **Explicit > Implicit**: Clear, explicit code over clever shortcuts - MANDATORY
- **Simple > Complex**: Simple solutions over complex ones - MANDATORY
- **Errors Never Pass Silently**: All errors must be handled - MANDATORY

## ⚠️ TYPE SAFETY (STRICT MANDATORY - ZERO TOLERANCE) ⚠️

### Pydantic 2 Models (STRICT MANDATORY)

- **ALL structured data MUST use Pydantic `BaseModel`** - NO EXCEPTIONS
- **Use Pydantic 2 API**: `model_validate()`, `model_dump()`, `ConfigDict` - MANDATORY
- Applies to: function return types, parameters, API responses, MCP tool results, nested structures
- CI MUST fail on violations
- See `python-pydantic-standards.mdc` for comprehensive Pydantic 2 guidelines

**FORBIDDEN:**

- ❌ `def func() -> dict:` (Untyped dict)
- ❌ `def func() -> list:` (Untyped list)
- ❌ `def func() -> Any:` (Any type)
- ❌ `def func() -> dict[str, Any]:` (Any in dict)
- ❌ `def func(data: dict) -> dict:` (Untyped parameters)
- ❌ Using Pydantic 1 API (`.dict()`, `.json()`, `parse_obj()`, `from_orm()`, `class Config:`)

**REQUIRED:**

- ✅ `def func() -> ResultModel:` (Pydantic model)
- ✅ `def func() -> dict[str, int]:` (Explicit types)
- ✅ `def func() -> list[ItemModel]:` (Pydantic model list)
- ✅ `def func(data: UserModel) -> ProcessResult:` (Pydantic models)
- ✅ Use `model_validate()` instead of `parse_obj()` or `from_orm()`
- ✅ Use `model_dump()` instead of `.dict()`
- ✅ Use `ConfigDict` instead of `class Config:`
- ✅ Use `Literal` types for status/enum fields

### Type Hints (MANDATORY)

- **100% Type Coverage**: All functions, methods, classes MUST have complete type hints
- **Built-in Generics**: Use `list[str]`, `dict[str, int]` (Python 3.13+) - NOT `typing.List`, `typing.Dict`
- **Optional Types**: Use `T | None` (NOT `Optional[T]` or `Union[T, None]`)

- **Self Type**: Use `typing.Self` for methods returning class instances
- **TypedDict**: Use `typing.Required`/`typing.NotRequired` for optional fields
- **Callable**: Use `Callable[[ArgTypes], ReturnType]` for function parameters

**FORBIDDEN:**

- ❌ `Any` type - STRICTLY FORBIDDEN (use Protocols, Pydantic models, or `object`)
- ❌ Untyped `dict`, `list`, `tuple`, `set` - STRICTLY FORBIDDEN
- ❌ `typing.List`, `typing.Dict` when built-ins available - FORBIDDEN

**REQUIRED:**

- ✅ `dict[str, str]` - Explicit types
- ✅ `list[UserModel]` - Pydantic model types
- ✅ `object` with `isinstance()` narrowing for truly unknown types

### Concrete Types (MANDATORY)

- **Investigate actual types**: Before using `object`, determine the real type
- **Replace `object` with concrete types**: Use specific types wherever possible
- **Make types MORE specific**: Prefer `dict[str, str]` over `dict[str, object]`
- **Avoid unnecessary abstractions**: Use `dict` directly, not `Mapping`

**FORBIDDEN:**

- ❌ `object` when concrete types available
- ❌ Replacing concrete types with `object`
- ❌ Using abstractions like `Mapping` when `dict` works

## Code Formatting (ENFORCED)

- **Black**: 88-character line length - MANDATORY
- **isort**: Black-compatible settings - MANDATORY
- **No Manual Formatting**: Never adjust Black-formatted code
- **Quotes**: Double quotes for strings, single for character constants
- **Trailing Commas**: Required in multi-line structures

### Import Organization

```python
# Standard library
import os
from pathlib import Path

# Third-party
from fastapi import FastAPI
from pydantic import BaseModel

# Local
from .config import Config
```

### `TYPE_CHECKING` Conditional Imports (FORBIDDEN)

**CRITICAL**: The `if TYPE_CHECKING:` pattern is a code smell and MUST NOT be used.

```python
# ❌ FORBIDDEN - TYPE_CHECKING conditional imports
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import SomeModel  # Circular import workaround

# ❌ FORBIDDEN - Forward references as strings due to circular imports
def process(data: "SomeModel") -> "ResultModel":
    pass
```

**Why it's forbidden:**

- It's a workaround for circular imports, not a solution
- Indicates poor module architecture and tight coupling
- Creates runtime vs type-checking behavior mismatch
- Makes code harder to understand and maintain
- Breaks IDE features and refactoring tools

**How to fix circular imports properly:**

1. **Extract shared types to a separate module:**

   ```python
   # ✅ REQUIRED - Create a dedicated types/models module
   # src/cortex/core/models.py - shared models
   # src/cortex/core/protocols.py - shared protocols
   # Then import from there in both modules
   ```

2. **Use dependency inversion with Protocols:**

   ```python
   # ✅ REQUIRED - Define Protocol in the dependent module
   from typing import Protocol
   
   class DataProvider(Protocol):
       def get_data(self) -> list[str]: ...
   
   def process(provider: DataProvider) -> None:
       data = provider.get_data()
   ```

3. **Restructure module hierarchy:**
   - Move shared types to a lower-level module
   - Ensure dependencies flow in one direction (no cycles)
   - Consider if the modules should be merged or split differently

4. **Use late imports inside functions (last resort):**

   ```python
   # ✅ ACCEPTABLE (only when restructuring is not feasible)
   def process() -> ResultModel:
       from .models import ResultModel  # Import at runtime when needed
       return ResultModel(...)
   ```

**Violations:**

- ❌ `from typing import TYPE_CHECKING` - FORBIDDEN
- ❌ `if TYPE_CHECKING:` blocks - FORBIDDEN
- ❌ String annotations to avoid imports (e.g., `"SomeModel"`) - FORBIDDEN when caused by circular imports

## Error Handling (ENFORCED)

- **Custom Exception Classes**: Domain-specific exceptions - MANDATORY
- **Exception Hierarchy**: Proper inheritance from standard library - MANDATORY
- **Exception Groups**: Use `except*` for multiple exception types (Python 3.13+) - MANDATORY
- **Context Managers**: Use `with` statements for resource management - MANDATORY
- **Logging Before Raising**: Log errors before re-raising - MANDATORY
- **No Bare Except**: Never use `except:` without specific types - MANDATORY

```python
class ValidationError(ValueError):
    """Raised when data validation fails."""
    pass

def validate_data(data: dict) -> None:
    try:
        if not data.get('name'):
            raise ValidationError("Name is required")
    except KeyError as e:
        logger.error(f"Missing field: {e}")
        raise ValidationError(f"Missing field: {e}") from e
```

## Function Design (ENFORCED)

- **Single Responsibility**: Each function does one thing - MANDATORY
- **Max 30 Lines**: Functions must not exceed 30 logical lines - MANDATORY
- **Descriptive Names**: Use `verb_noun` format - MANDATORY
- **Docstrings**: All public functions MUST have docstrings (Google/NumPy style) - MANDATORY
- **Parameter Defaults**: Use `None` as default for mutable arguments - MANDATORY

## Class Design (ENFORCED)

- **Dataclasses**: Use `@dataclass` for data-only classes - MANDATORY
- **Properties**: Use `@property` for computed attributes - MANDATORY
- **Dunder Methods**: Implement `__str__`, `__repr__`, `__eq__` as needed - MANDATORY
- **Context Managers**: Implement `__enter__`/`__exit__` for resources - MANDATORY
- **Abstract Base Classes**: Use `abc.ABC` for interfaces - MANDATORY

## Module Visibility (ENFORCED)

- **Cross-module symbols MUST be public**: No `_` prefix for symbols accessed from other modules
- **Private symbols are module-internal only**: `_` prefix only for same-module use
- **NEVER use type-checker suppressions**: `# pyright: ignore[reportPrivateUsage]` is FORBIDDEN
- **Fix by making symbol public**: Rename everywhere (definition, internal calls, external usages)
- **CI MUST fail** if private symbols accessed across modules

## Python 3.13+ Features (MANDATORY)

- **Type Hints**: `T | None`, `typing.Self`, `Required`/`NotRequired`
- **Async**: `asyncio.timeout()`, `asyncio.TaskGroup`
- **Itertools**: `itertools.batched()`, `itertools.pairwise()`
- **Contextlib**: `contextlib.chdir()`
- **Functools**: `@cache` for unbounded caching
- **Exceptions**: `except*` for ExceptionGroup handling
- **Generics**: Built-in `list[str]`, `dict[str, int]`

## Async/Await (ENFORCED)

- **Async Functions**: Use `async def` for I/O-bound operations - MANDATORY
- **Await Correctly**: Only `await` async functions - MANDATORY
- **Async Context Managers**: Use `async with` for async resources - MANDATORY
- **Async Iterators**: Use `async for` for async iteration - MANDATORY
- **Task Groups**: Use `asyncio.TaskGroup` for concurrent operations - MANDATORY
- **Timeout**: Use `asyncio.timeout()` instead of `asyncio.wait_for()` (Python 3.13+) - MANDATORY

## Testing (ENFORCED)

- **pytest Framework**: Use pytest for all testing - MANDATORY
- **Test Discovery**: Follow `test_*.py` and `*_test.py` naming - MANDATORY
- **AAA Pattern**: Use Arrange-Act-Assert in all tests - MANDATORY
- **Descriptive Names**: Use `test_functionality_when_condition` format - MANDATORY
- **100% Coverage**: Aim for 100% test coverage on new code - MANDATORY

## Performance (ENFORCED)

- **List Comprehensions**: Prefer over loops - MANDATORY
- **Generator Expressions**: Use for large datasets - MANDATORY
- **Efficient Data Structures**: Choose appropriate structures (dict vs list) - MANDATORY
- **Lazy Evaluation**: Use when possible - MANDATORY
- **Memory Management**: Avoid loading large datasets into memory - MANDATORY

## Security (ENFORCED)

- **Input Validation**: Validate all external inputs - MANDATORY
- **SQL Injection Prevention**: Use parameterized queries - MANDATORY
- **XSS Prevention**: Sanitize HTML output - MANDATORY
- **Secure Defaults**: Use secure defaults for configurations - MANDATORY
- **Dependency Scanning**: Regularly update and scan dependencies - MANDATORY

## Tooling (ENFORCED)

- **Black**: Code formatting - MANDATORY
- **isort**: Import sorting - MANDATORY
- **Pyright**: Static type checking with strict mode - MANDATORY
- **flake8**: Linting - MANDATORY
- **pytest**: Testing framework - MANDATORY
- **coverage.py**: Test coverage - MANDATORY
- **pre-commit**: Pre-commit hooks - MANDATORY

### Pyright Configuration

- **Type Checking Mode**: `"strict"` - Maximum type safety
- **Python Version**: `"3.13"`
- All type issues are errors
- Optional member access, operands, subscripts, calls are errors
- Unknown types are errors
- Untyped decorators, base classes are errors

## Violations (BLOCKED)

- ❌ Missing type hints on functions/methods
- ❌ Functions exceeding 30 lines
- ❌ Bare `except:` clauses
- ❌ Manual import sorting/formatting
- ❌ Missing docstrings on public functions
- ❌ Use of `Any` type (STRICTLY FORBIDDEN)
- ❌ Use of untyped `dict`, `list`, `tuple`, `set` (STRICTLY FORBIDDEN)
- ❌ Use of `typing.List`, `typing.Dict` when built-ins available (FORBIDDEN)
- ❌ Use of `object` when concrete types available (FORBIDDEN)
- ❌ Missing Pydantic models for structured return types (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts before returning (STRICTLY FORBIDDEN)
- ❌ Missing `Literal` types for status/enum fields (STRICTLY FORBIDDEN)
- ❌ Synchronous I/O in async contexts
- ❌ Type-checker suppressions for private usage (FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Using `regex` parameter instead of `pattern` in Field (STRICTLY FORBIDDEN)
- ❌ Missing `@classmethod` decorator on `@field_validator` (STRICTLY FORBIDDEN)
- ❌ Using mutable defaults without `default_factory` (STRICTLY FORBIDDEN)
- ❌ Using `TYPE_CHECKING` conditional imports (STRICTLY FORBIDDEN)
- ❌ Using `if TYPE_CHECKING:` blocks (STRICTLY FORBIDDEN)
- ❌ String annotations to avoid circular imports (STRICTLY FORBIDDEN)

## Enforcement

- **Pre-commit hooks**: Verify compliance before commit
- **CI Integration**: Automated checks fail builds on violations
- **Code review**: Reject PRs with violations
- **Type checking**: Pyright must pass with strict mode
- **Test coverage**: Must maintain >90% coverage
- **NO exceptions**: All violations must be fixed before merge
