---
globs: *.py
alwaysApply: false
---

# Python Coding Standards (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## Core Principles

- **PEP 8 Compliance**: MANDATORY
- **Readability First**: Code must be immediately understandable - MANDATORY
- **Explicit > Implicit**: Clear, explicit code over clever shortcuts - MANDATORY
- **Simple > Complex**: Simple solutions over complex ones - MANDATORY
- **Errors Never Pass Silently**: All errors must be handled - MANDATORY

## ⚠️ TYPE SAFETY (STRICT MANDATORY - ZERO TOLERANCE) ⚠️

### Pydantic 2 Models (STRICT MANDATORY)

- **ALL structured data MUST use Pydantic `BaseModel`** - NO EXCEPTIONS
- **TypedDict is FORBIDDEN** for new code - use Pydantic BaseModel instead
- **Validation Step**: Before committing, run: `pyright src/` and verify no TypedDict usage in new code
- **CI Enforcement**: CI MUST fail on TypedDict usage in new modules
- **Use Pydantic 2 API**: `model_validate()`, `model_dump()`, `ConfigDict` - MANDATORY
- Applies to: function return types, parameters, API responses, MCP tool results, nested structures
- CI MUST fail on violations
- See `python-pydantic-standards.mdc` for comprehensive Pydantic 2 guidelines

**FORBIDDEN:**

- ❌ `def func() -> dict:` (Untyped dict)
- ❌ `def func() -> list:` (Untyped list)
- ❌ `def func() -> Any:` (Any type)
- ❌ `def func() -> dict[str, Any]:` (Any in dict)
- ❌ `def func(data: dict) -> dict:` (Untyped parameters)
- ❌ Using Pydantic 1 API (`.dict()`, `.json()`, `parse_obj()`, `from_orm()`, `class Config:`)

**REQUIRED:**

- ✅ `def func() -> ResultModel:` (Pydantic model)
- ✅ `def func() -> dict[str, int]:` (Explicit types)
- ✅ `def func() -> list[ItemModel]:` (Pydantic model list)
- ✅ `def func(data: UserModel) -> ProcessResult:` (Pydantic models)
- ✅ Use `model_validate()` instead of `parse_obj()` or `from_orm()`
- ✅ Use `model_dump()` instead of `.dict()`
- ✅ Use `ConfigDict` instead of `class Config:`
- ✅ Use `Literal` or **prefer `class X(str, Enum)`** for status/fixed-set fields; use Enum when the set is reused or branched on (see "Fixed Sets of Values: Prefer Enums")

### Type Hints (MANDATORY)

- **100% Type Coverage**: All functions, methods, classes MUST have complete type hints
- **Built-in Generics**: Use `list[str]`, `dict[str, int]` (Python 3.13+) - NOT `typing.List`, `typing.Dict`
- **Optional Types**: Use `T | None` (NOT `Optional[T]` or `Union[T, None]`)
- See "Type Narrowing with assert" section for handling Optional types with control flow guarantees.

- **Self Type**: Use `typing.Self` for methods returning class instances
- **TypedDict**: Use `typing.Required`/`typing.NotRequired` for optional fields
- **Callable**: Use `Callable[[ArgTypes], ReturnType]` for function parameters

**FORBIDDEN:**

- ❌ `Any` type - STRICTLY FORBIDDEN (use Protocols, Pydantic models, or `object`)
- ❌ Untyped `dict`, `list`, `tuple`, `set` - STRICTLY FORBIDDEN
- ❌ `typing.List`, `typing.Dict` when built-ins available - FORBIDDEN

**REQUIRED:**

- ✅ `dict[str, str]` - Explicit types
- ✅ `list[UserModel]` - Pydantic model types
- ✅ `object` with `isinstance()` narrowing for truly unknown types

### Type Narrowing with assert

- **Pattern**: When control flow guarantees a value is not None (e.g. early return on None case), use `assert value is not None` to narrow type for type checker.
- **Example**:

  ```python
  def process_value(value: int | None) -> int:
      if value is None:
          return 0
      assert value is not None  # Type narrowing for type checker
      return value * 2
  ```

- **Rationale**: Pyright type checker does not always infer type narrowing from control flow. Explicit assertion provides clear type narrowing signal.
- **When to use**: Use when control flow guarantees non-None but type checker still reports error; do not use for runtime validation (use proper error handling instead).

### Concrete Types (MANDATORY)

- **Investigate actual types**: Before using `object`, determine the real type
- **Replace `object` with concrete types**: Use specific types wherever possible
- **Make types MORE specific**: Prefer `dict[str, str]` over `dict[str, object]`
- **Avoid unnecessary abstractions**: Use `dict` directly, not `Mapping`

**FORBIDDEN:**

- ❌ `object` when concrete types available
- ❌ Replacing concrete types with `object`
- ❌ Using abstractions like `Mapping` when `dict` works

### Fixed Sets of Values: Prefer Enums (MANDATORY)

- **Use `class X(str, Enum)` for fixed sets of string values; reserve Literal for one-off or external API constraints.** Prefer enums over `Literal[...]` or raw strings when the set is reused, branched on, or validated (e.g. operation names, check types, actions, status codes).
- **Wire format stays string**: At MCP/JSON boundaries, continue to accept and return strings; use `.value` when writing to JSON or response dicts so the API shape is unchanged.
- **Validate at boundary**: In MCP handlers, accept `str` from the client; parse to enum (e.g. `try: PreCommitCheck(name)` / `except ValueError`) and use enum members internally; invalid names skip or return a clear error.
- **Literal is forbidden in internal Pydantic models** (e.g. `tools/*_models.py`, any `BaseModel` under `src/`). Use `class X(str, Enum)` for all fixed-set fields. Literal remains acceptable only at external API boundaries (e.g. MCP tool parameter type hints). See `python-pydantic-standards.mdc` "Fixed-set fields" for full rule.

**REQUIRED:**

- ✅ Define `class X(str, Enum): MEMBER = "value"` for closed sets (operations, check types, actions, etc.)
- ✅ Use enum members in branching: `if PreCommitCheck.FIX_ERRORS in checks_to_perform:`
- ✅ Use `.value` when writing to dict/JSON: `results[PreCommitCheck.FIX_ERRORS.value] = result`
- ✅ Validate input strings to enum at the boundary; reject or skip invalid values with a clear error

**FORBIDDEN:**

- ❌ Repeated raw string literals for the same fixed set (e.g. `"fix_errors"` in multiple files or branches) when an enum exists or should be introduced
- ❌ Using only `Literal["a", "b", "c"]` for a set that is branched on in multiple places—prefer a shared enum

**Example** (from pre_commit_helpers / pre_commit_tools):

```python
class PreCommitCheck(str, Enum):
    """Fixed set of pre-commit check names."""
    FIX_ERRORS = "fix_errors"
    FORMAT = "format"
    TYPE_CHECK = "type_check"
    QUALITY = "quality"
    TESTS = "tests"

def determine_checks_to_perform(checks: Sequence[str] | None) -> list[PreCommitCheck]:
    if not checks:
        return list(DEFAULT_CHECKS)
    result: list[PreCommitCheck] = []
    for name in checks:
        try:
            result.append(PreCommitCheck(name))
        except ValueError:
            continue
    return result if result else list(DEFAULT_CHECKS)

# In handler: use enum in branching, .value for JSON
if PreCommitCheck.FIX_ERRORS in checks_to_perform:
    results[PreCommitCheck.FIX_ERRORS.value] = fix_result
```

**Reference**: Existing pattern: `PreCommitCheck` in `pre_commit_helpers` / `pre_commit_tools`.

### JsonValue at MCP Boundaries (MANDATORY)

**CRITICAL**: At MCP (Model Context Protocol) boundaries, JSON data arrives as `JsonValue` (a recursive type alias for JSON-serializable values). This data MUST be normalized to concrete Python types before use.

**Pattern**: Cross-cutting utilities that consume `JsonValue` MUST normalize inputs at the top of the function.

**REQUIRED:**

- ✅ Normalize `JsonValue` inputs to concrete types before use
- ✅ Create helper functions like `_to_timeout_value()` to normalize specific value types
- ✅ Perform normalization at the top of functions that accept `JsonValue`
- ✅ Use `isinstance()` checks and type narrowing for safe conversion

**FORBIDDEN:**

- ❌ Passing `JsonValue` directly to functions expecting concrete types (e.g., `float | None`)
- ❌ Assuming `JsonValue` is already the correct type without validation
- ❌ Using `JsonValue` in business logic without normalization

**Example Pattern** (from `mcp_stability.py`):

```python
def _to_timeout_value(value: JsonValue | None) -> float | None:
    """Convert JsonValue to a valid timeout value.
    
    Ensures we only accept float-compatible values and ignore invalid ones.
    """
    if value is None:
        return None
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        try:
            return float(value)
        except ValueError:
            logger.warning("Invalid timeout value %r, falling back to defaults", value)
            return None
    logger.warning("Unsupported timeout type %s, falling back to defaults", type(value))
    return None

async def with_mcp_stability[T](
    func: Callable[..., Awaitable[T]],
    *args: JsonValue,
    timeout: JsonValue | None = None,  # Accepts JsonValue
    stability_timeout: JsonValue | None = None,  # Accepts JsonValue
    **kwargs: JsonValue,
) -> T:
    """Execute MCP tool with stability protections."""
    # Normalize JsonValue to concrete types at the top
    stability_timeout_value = _to_timeout_value(stability_timeout)  # float | None
    timeout_value = _to_timeout_value(timeout)  # float | None
    
    # Now use concrete types in business logic
    effective_timeout = (
        stability_timeout_value or timeout_value or float(MCP_TOOL_TIMEOUT_SECONDS)
    )
    # ... rest of function uses concrete types
```

**Alternative Pattern** (push normalization to callers):

```python
# ✅ REQUIRED - Accept concrete types only, push normalization to callers
async def execute_with_timeout(
    func: Callable[..., Awaitable[T]],
    timeout: float | None = None,  # Concrete type, not JsonValue
    **kwargs: JsonValue,
) -> T:
    """Execute function with timeout protection."""
    # Function uses concrete types directly
    effective_timeout = timeout or float(DEFAULT_TIMEOUT)
    # ... rest of function
```

**Guidelines:**

1. **MCP boundary functions**: Accept `JsonValue` and normalize immediately
2. **Internal business logic**: Use concrete types only
3. **Helper functions**: Create normalization helpers for common conversions (`_to_timeout_value()`, `_to_string_list()`, etc.)
4. **Error handling**: Log warnings for invalid conversions, fall back to safe defaults
5. **Type narrowing**: Use `isinstance()` checks to narrow `JsonValue` to specific types

**Cross-check**: Audit all MCP utilities that consume `JsonValue` and ensure they follow this pattern.

## Code Formatting (ENFORCED)

- **Black**: 88-character line length - MANDATORY
- **isort**: Black-compatible settings - MANDATORY
- **No Manual Formatting**: Never adjust Black-formatted code
- **Quotes**: Double quotes for strings, single for character constants
- **Implicit String Concatenation**: FORBIDDEN - never rely on adjacent string literals (including f-strings); use a single f-string or explicit `+`/`str.join()` instead (Pyright `reportImplicitStringConcatenation` is configured as `error`)
- **Trailing Commas**: Required in multi-line structures

### Import Organization

```python
# Standard library
import os
from pathlib import Path

# Third-party
from fastapi import FastAPI
from pydantic import BaseModel

# Local
from .config import Config
```

### `TYPE_CHECKING` Conditional Imports (FORBIDDEN)

**CRITICAL**: The `if TYPE_CHECKING:` pattern is a code smell and MUST NOT be used.

```python
# ❌ FORBIDDEN - TYPE_CHECKING conditional imports
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .models import SomeModel  # Circular import workaround

# ❌ FORBIDDEN - Forward references as strings due to circular imports
def process(data: "SomeModel") -> "ResultModel":
    pass
```

**Why it's forbidden:**

- It's a workaround for circular imports, not a solution
- Indicates poor module architecture and tight coupling
- Creates runtime vs type-checking behavior mismatch
- Makes code harder to understand and maintain
- Breaks IDE features and refactoring tools

**How to fix circular imports properly:**

1. **Extract shared types to a separate module:**

   ```python
   # ✅ REQUIRED - Create a dedicated types/models module
   # src/cortex/core/models.py - shared models
   # src/cortex/core/protocols.py - shared protocols
   # Then import from there in both modules
   ```

2. **Use dependency inversion with Protocols:**

   ```python
   # ✅ REQUIRED - Define Protocol in the dependent module
   from typing import Protocol
   
   class DataProvider(Protocol):
       def get_data(self) -> list[str]: ...
   
   def process(provider: DataProvider) -> None:
       data = provider.get_data()
   ```

   When the same Protocol is used by **multiple modules**, define it **once** in a dedicated `*_protocols.py` or `protocols.py` module and import—do **not** duplicate across modules (DRY).

3. **Restructure module hierarchy:**
   - Move shared types to a lower-level module
   - Ensure dependencies flow in one direction (no cycles)
   - Consider if the modules should be merged or split differently

4. **Use late imports inside functions (last resort):**

   ```python
   # ✅ ACCEPTABLE (only when restructuring is not feasible)
   def process() -> ResultModel:
       from .models import ResultModel  # Import at runtime when needed
       return ResultModel(...)
   ```

**Violations:**

- ❌ `from typing import TYPE_CHECKING` - FORBIDDEN
- ❌ `if TYPE_CHECKING:` blocks - FORBIDDEN
- ❌ String annotations to avoid imports (e.g., `"SomeModel"`) - FORBIDDEN when caused by circular imports

## Error Handling (ENFORCED)

- **Custom Exception Classes**: Domain-specific exceptions - MANDATORY
- **Exception Hierarchy**: Proper inheritance from standard library - MANDATORY
- **Exception Groups**: Use `except*` for multiple exception types (Python 3.13+) - MANDATORY
- **Context Managers**: Use `with` statements for resource management - MANDATORY
- **Logging Before Raising**: Log errors before re-raising - MANDATORY
- **No Bare Except**: Never use `except:` without specific types - MANDATORY

```python
class ValidationError(ValueError):
    """Raised when data validation fails."""
    pass

def validate_data(data: dict) -> None:
    try:
        if not data.get('name'):
            raise ValidationError("Name is required")
    except KeyError as e:
        logger.error(f"Missing field: {e}")
        raise ValidationError(f"Missing field: {e}") from e
```

## Function Design (ENFORCED)

- **Single Responsibility**: Each function does one thing - MANDATORY
- **Max 30 Lines**: Functions must not exceed 30 logical lines - MANDATORY
- **Descriptive Names**: Use `verb_noun` format - MANDATORY
- **Docstrings**: All public functions MUST have docstrings (Google/NumPy style) - MANDATORY
- **Parameter Defaults**: Use `None` as default for mutable arguments - MANDATORY

## Class Design (ENFORCED)

- **Dataclasses**: Use `@dataclass` for data-only classes - MANDATORY
- **Properties**: Use `@property` for computed attributes - MANDATORY
- **Dunder Methods**: Implement `__str__`, `__repr__`, `__eq__` as needed - MANDATORY
- **Context Managers**: Implement `__enter__`/`__exit__` for resources - MANDATORY
- **Abstract Base Classes**: Use `abc.ABC` for interfaces - MANDATORY

## Module Visibility (ENFORCED)

- **Cross-module symbols MUST be public**: No `_` prefix for symbols accessed from other modules
- **Private symbols are module-internal only**: `_` prefix only for same-module use
- **NEVER use type-checker suppressions**: `# pyright: ignore[reportPrivateUsage]` is FORBIDDEN
- **Fix by making symbol public**: Rename everywhere (definition, internal calls, external usages)
- **CI MUST fail** if private symbols accessed across modules

## Public API and Type Names (ENFORCED)

- **Public signatures must not use private type names**: Public functions, methods, and their parameter/return type hints must not reference types or type aliases whose names start with an underscore. Any type that appears in a public signature must have a public name.
- **Export public types**: Export such types via `__all__` if they are part of the module's API.
- **Rationale**: In Python, a leading underscore denotes "internal"; using such names in public signatures breaks the convention that the public API surface uses only public names.

**FORBIDDEN:**

- ❌ Public function or method signature with `_MCPContext`, `_LogLevel`, or any `_`-prefixed type in parameters or return type

**REQUIRED:**

- ✅ Use public type names (e.g. `MCPContext`, `LogLevel`) in all public function/method signatures
- ✅ Add types to `__all__` when they are part of the module's API

## Third-Party and SDK Generic Types (ENFORCED)

- **Use library type parameters**: When using generic types from third-party or SDK code (e.g. MCP `Context`), use the same type parameters as in the library's public API or documented examples (e.g. `Context[ServerSession, object]`).
- **Do not substitute blindly**: Do not substitute `object` or other types without verifying they satisfy the generic's type bounds.

**REQUIRED:**

- ✅ Match SDK/public API: `Context[ServerSession, object]` when that is what the SDK's `get_context()` returns
- ✅ Verify type bounds when using different parameters

**FORBIDDEN:**

- ❌ Using `Context[object, object]` or other ad-hoc parameters when the SDK documents or uses a different shape (e.g. `Context[ServerSession, object]`)

## Python 3.13+ Features (MANDATORY)

- **Type Hints**: `T | None`, `typing.Self`, `Required`/`NotRequired`
- **Async**: `asyncio.timeout()`, `asyncio.TaskGroup`
- **Itertools**: `itertools.batched()`, `itertools.pairwise()`
- **Contextlib**: `contextlib.chdir()`
- **Functools**: `@cache` for unbounded caching
- **Exceptions**: `except*` for ExceptionGroup handling
- **Generics**: Built-in `list[str]`, `dict[str, int]`

## Async/Await (ENFORCED)

- **Async Functions**: Use `async def` for I/O-bound operations - MANDATORY
- **Await Correctly**: Only `await` async functions - MANDATORY
- **Async Context Managers**: Use `async with` for async resources - MANDATORY
- **Async Iterators**: Use `async for` for async iteration - MANDATORY
- **Task Groups**: Use `asyncio.TaskGroup` for concurrent operations - MANDATORY
- **Timeout**: Use `asyncio.timeout()` instead of `asyncio.wait_for()` (Python 3.13+) - MANDATORY

## Testing (ENFORCED)

- **pytest Framework**: Use pytest for all testing - MANDATORY
- **Test Discovery**: Follow `test_*.py` and `*_test.py` naming - MANDATORY
- **AAA Pattern**: Use Arrange-Act-Assert in all tests - MANDATORY
- **Descriptive Names**: Use `test_functionality_when_condition` format - MANDATORY
- **100% Coverage**: Aim for 100% test coverage on new code - MANDATORY

## Performance (ENFORCED)

- **List Comprehensions**: Prefer over loops - MANDATORY
- **Generator Expressions**: Use for large datasets - MANDATORY
- **Efficient Data Structures**: Choose appropriate structures (dict vs list) - MANDATORY
- **Lazy Evaluation**: Use when possible - MANDATORY
- **Memory Management**: Avoid loading large datasets into memory - MANDATORY

## Security (ENFORCED)

- **Input Validation**: Validate all external inputs - MANDATORY
- **SQL Injection Prevention**: Use parameterized queries - MANDATORY
- **XSS Prevention**: Sanitize HTML output - MANDATORY
- **Secure Defaults**: Use secure defaults for configurations - MANDATORY
- **Dependency Scanning**: Regularly update and scan dependencies - MANDATORY

## Tooling (ENFORCED)

- **Black**: Code formatting - MANDATORY
- **isort**: Import sorting - MANDATORY
- **Pyright**: Static type checking with strict mode - MANDATORY
- **flake8**: Linting - MANDATORY
- **pytest**: Testing framework - MANDATORY
- **coverage.py**: Test coverage - MANDATORY
- **pre-commit**: Pre-commit hooks - MANDATORY

### Pyright Configuration

- **Type Checking Mode**: `"strict"` - Maximum type safety
- **Python Version**: `"3.13"`
- All type issues are errors
- Optional member access, operands, subscripts, calls are errors
- Unknown types are errors
- Untyped decorators, base classes are errors

## Violations (BLOCKED)

- ❌ Missing type hints on functions/methods
- ❌ Functions exceeding 30 lines
- ❌ Bare `except:` clauses
- ❌ Manual import sorting/formatting
- ❌ Missing docstrings on public functions
- ❌ Use of `Any` type (STRICTLY FORBIDDEN)
- ❌ Use of untyped `dict`, `list`, `tuple`, `set` (STRICTLY FORBIDDEN)
- ❌ Use of `typing.List`, `typing.Dict` when built-ins available (FORBIDDEN)
- ❌ Use of `object` when concrete types available (FORBIDDEN)
- ❌ Missing Pydantic models for structured return types (STRICTLY FORBIDDEN)
- ❌ Converting Pydantic models to dicts before returning (STRICTLY FORBIDDEN)
- ❌ Missing `Literal` or enum types for status/fixed-set fields (STRICTLY FORBIDDEN)
- ❌ Repeated raw string literals for a fixed set that is branched on or validated—use `class X(str, Enum)` instead (see "Fixed Sets of Values: Prefer Enums")
- ❌ Synchronous I/O in async contexts
- ❌ Type-checker suppressions for private usage (FORBIDDEN)
- ❌ Using Pydantic 1 API: `.dict()`, `.json()`, `parse_obj()`, `from_orm()` (STRICTLY FORBIDDEN)
- ❌ Using `class Config:` instead of `ConfigDict` (STRICTLY FORBIDDEN)
- ❌ Using `regex` parameter instead of `pattern` in Field (STRICTLY FORBIDDEN)
- ❌ Missing `@classmethod` decorator on `@field_validator` (STRICTLY FORBIDDEN)
- ❌ Using mutable defaults without `default_factory` (STRICTLY FORBIDDEN)
- ❌ Using `TYPE_CHECKING` conditional imports (STRICTLY FORBIDDEN)
- ❌ Using `if TYPE_CHECKING:` blocks (STRICTLY FORBIDDEN)
- ❌ String annotations to avoid circular imports (STRICTLY FORBIDDEN)
- ❌ Duplicate Protocol or type definitions across modules (FORBIDDEN)—define in one place and reuse

## Enforcement

- **Pre-commit hooks**: Verify compliance before commit
- **CI Integration**: Automated checks fail builds on violations
- **Code review**: Reject PRs with violations
- **Type checking**: Pyright must pass with strict mode
- **Test coverage**: Must maintain >90% coverage
- **NO exceptions**: All violations must be fixed before merge
