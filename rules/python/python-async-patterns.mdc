---
globs: *.py
alwaysApply: false
---

# Python Async Patterns (STRICT MANDATORY - ZERO TOLERANCE)

**ENFORCEMENT**: All rules are MANDATORY. CI MUST fail on violations. NO exceptions.

## Core Principles (ENFORCED)

- **Async First**: All I/O operations must be async by default - MANDATORY
- **Non-blocking**: Never block the event loop with synchronous operations - MANDATORY
- **Structured Concurrency**: Use `asyncio` structured concurrency patterns - MANDATORY
- **Resource Management**: Proper cleanup of async resources - MANDATORY
- **Error Propagation**: Async exceptions must be properly handled - MANDATORY

## Async/Await Usage (ENFORCED)

- **Async Functions**: Use `async def` for I/O-bound operations - MANDATORY
- **Await Correctly**: Only `await` async functions - MANDATORY
- **Async Context Managers**: Use `async with` for async resources - MANDATORY
- **Async Iterators**: Use `async for` for async iteration - MANDATORY

```python
# ✅ REQUIRED
async def fetch_user_data(user_id: int) -> User:
    async with database.connection() as conn:
        return await conn.fetchrow("SELECT * FROM users WHERE id = $1", user_id)

# ❌ PROHIBITED
def fetch_user_data(user_id: int) -> User:  # BLOCKED: Should be async
    return database.query("SELECT * FROM users WHERE id = $1", user_id)
```

## Structured Concurrency (ENFORCED)

- **Task Groups**: Use `asyncio.TaskGroup` for concurrent operations - MANDATORY
- **Timeout**: Use `asyncio.timeout()` instead of `asyncio.wait_for()` (Python 3.13+) - MANDATORY
- **Cancellation**: Handle cancellation gracefully - MANDATORY

```python
import asyncio

# ✅ REQUIRED
async def process_multiple_items(items: list[Item]) -> list[Result]:
    async with asyncio.TaskGroup() as tg:
        tasks = [tg.create_task(process_item(item)) for item in items]
    return [task.result() for task in tasks]

# ✅ REQUIRED - asyncio.timeout() (Python 3.13+)
async def fetch_with_timeout(url: str, timeout: float = 5.0) -> bytes:
    async with asyncio.timeout(timeout):  # Preferred over asyncio.wait_for()
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.read()

# ❌ PROHIBITED
async def fetch_with_wait_for(url: str, timeout: float = 5.0) -> bytes:
    return await asyncio.wait_for(response.read(), timeout=timeout)  # BLOCKED
```

## Async Context Managers (ENFORCED)

- **Implement `__aenter__` and `__aexit__`**: Proper async context manager protocol - MANDATORY
- **Resource Cleanup**: Always clean up resources in `__aexit__` - MANDATORY

```python
class AsyncDatabaseConnection:
    async def __aenter__(self):
        self.connection = await asyncpg.connect(self.dsn)
        return self.connection

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.connection.close()
```

## Async Generators (ENFORCED)

- **Async Generators**: Use `AsyncGenerator` for streaming data - MANDATORY
- **Proper Yielding**: Use `yield` in async generators - MANDATORY

```python
from typing import AsyncGenerator

async def async_data_stream() -> AsyncGenerator[dict[str, Any], None]:
    async for record in database_stream():
        processed = await process_record(record)
        yield processed
```

## Async Testing (ENFORCED)

- **pytest-asyncio**: Use `@pytest.mark.asyncio` for async tests - MANDATORY
- **Async Fixtures**: Use `pytest_asyncio.fixture` for async fixtures - MANDATORY
- **AsyncMock**: Use `AsyncMock` for mocking async dependencies - MANDATORY

```python
import pytest
from unittest.mock import AsyncMock

@pytest.mark.asyncio
async def test_async_function():
    service = AsyncUserService()
    mock_repo = AsyncMock()
    mock_repo.get_data.return_value = ["item1", "item2"]
    result = await service.get_data()
    assert result == ["item1", "item2"]
```

## Error Handling (ENFORCED)

- **Exception Chaining**: Chain exceptions properly with `from` - MANDATORY
- **Cancellation Handling**: Handle `asyncio.CancelledError` gracefully - MANDATORY
- **Timeout Handling**: Handle `TimeoutError` appropriately - MANDATORY

```python
async def risky_async_operation() -> Result:
    try:
        await asyncio.sleep(0.1)
        if random.random() < 0.3:
            raise ValueError("Operation failed")
        return Result.success("Operation completed")
    except ValueError as e:
        raise AsyncOperationError("Async operation failed") from e
    except asyncio.CancelledError:
        await cleanup_partial_work()
        raise
```

## Concurrency Control (ENFORCED)

- **Semaphores**: Use `Semaphore` to limit concurrent operations - MANDATORY
- **Bounded Concurrency**: Never allow unbounded concurrency - MANDATORY

```python
from asyncio import Semaphore

class AsyncWorkerPool:
    def __init__(self, max_concurrent: int = 10):
        self.semaphore = Semaphore(max_concurrent)

    async def execute_task(self, task_func, *args, **kwargs):
        async with self.semaphore:
            return await task_func(*args, **kwargs)
```

## CPU-Bound Tasks (ENFORCED)

- **Process Pool**: Use `ProcessPoolExecutor` for CPU-intensive tasks - MANDATORY
- **Async Wrapper**: Use `loop.run_in_executor()` for async contexts - MANDATORY
- **NEVER Block Event Loop**: Blocking CPU-bound work on event loop is FORBIDDEN - MANDATORY

```python
from concurrent.futures import ProcessPoolExecutor

async def async_cpu_task(data: Any) -> Any:
    loop = asyncio.get_running_loop()
    with ProcessPoolExecutor() as executor:
        return await loop.run_in_executor(executor, cpu_intensive_task, data)
```

## Violations (BLOCKED)

- ❌ Synchronous I/O operations in async contexts
- ❌ Blocking calls without `loop.run_in_executor()`
- ❌ Manual task management instead of structured concurrency
- ❌ Missing timeout protection on async operations
- ❌ Improper resource cleanup in async contexts
- ❌ Async functions that don't use `await` properly
- ❌ Missing exception chaining in async error handling
- ❌ Unbounded concurrency without semaphores
- ❌ CPU-bound work on async event loop
- ❌ Missing cancellation handling in long-running tasks
- ❌ Using `asyncio.wait_for()` instead of `asyncio.timeout()` (Python 3.13+)

## Enforcement

- **Static Analysis**: Use tools like `flake8-async` for async code validation
- **Runtime Monitoring**: Implement task monitoring in production
- **CI Integration**: Automated checks for async anti-patterns
- **Code Review**: Require async expertise for async code reviews
- **Testing**: Comprehensive async test coverage with proper fixtures
- **NO exceptions**: All async pattern violations must be fixed before merge
