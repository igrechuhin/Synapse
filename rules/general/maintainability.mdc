---
alwaysApply: true
---
# Maintainability & Architecture Rules (MANDATORY)

**ENFORCEMENT**: CI MUST fail on violations. All rules are MANDATORY. NO exceptions.

## Memory Bank Adoption (ENFORCED)

1. The project **MUST** include a memory bank with core files: projectBrief.md, productContext.md, systemPatterns.md, techContext.md, activeContext.md, progress.md, roadmap.md. Access memory bank files via Cortex MCP tool `manage_file(file_name="...", operation="read"|"write")`; resolve path via `get_structure_info()` → `structure_info.paths.memory_bank` if needed. Do not hardcode `.cursor/memory-bank` or `.cortex/memory-bank` in procedures.
2. **File responsibilities (no overlap)** - **activeContext.md** = completed work only; **roadmap.md** = future/upcoming work only. When work is completed, move it from roadmap to activeContext (add summary to activeContext, mark complete or remove from roadmap). Do not list the same work in both files.
3. **Follow Plan → Act workflow** when starting tasks and updating documentation.
4. **After every significant change** (or when triggered by **update memory bank / umb**), update all memory-bank files.
5. **Keep synchronized** - Memory bank files must be consistent with each other.
6. **Link validation** - After ANY file operation (add/move/remove/rename), validate all links in memory bank files using `validate_links()` tool. See [memory-bank-workflow.mdc](memory-bank-workflow.mdc) for details.

## File / Type Size Limits (ENFORCED)

1. **Maximum file length** – 400 lines (excluding license headers & import statements).
2. **Maximum function length** – 30 lines (logical lines, excluding doc comments & blank lines).
3. **One public/open/internal type per file** - Private/fileprivate helpers may share the file with their parent type.
4. **CI MUST fail** if these limits are exceeded.

## Helper Module Extraction Pattern (ENFORCED)

When file size or function length exceeds project limits, use the **helper module extraction pattern** to resolve quality violations. This is the standard approach for refactoring; prefer it over ad-hoc splitting.

**Proactive extraction**: When implementing new code, if a function approaches or exceeds 25 logical lines, extract helpers immediately rather than waiting for the quality gate to report a violation. This reduces rework and keeps functions within limits from the start.

### File Size Violations (exceeds 400 lines)

1. **Identify cohesive function groups** - Analyze the file to identify logically related functions that can be extracted together.
2. **Extract to dedicated helper module** - Create a new module using the naming convention `*_helpers.py` (e.g., `phase4_metadata_helpers.py`, `session_helpers.py`).
3. **Update imports** - Update imports in:
   - The original module (import from the new helper module)
   - All test files that import from the original module
   - Any other modules that reference the extracted functions
4. **Maintain test coverage** - Ensure both modules have comprehensive test coverage:
   - Move or duplicate relevant tests for extracted functions to test the new helper module
   - Update existing tests to reflect new import paths
   - Verify test coverage for both the original module and the new helper module

### Function Length Violations (exceeds 30 logical lines)

1. **Extract logic to helper functions**:
   - **If file is small** (< 350 lines): Extract helper functions in the same file
   - **If file is already large** (≥ 350 lines): Extract to a `*_helpers.py` module
2. **Keep main function as orchestrator** - The original function should become a clear orchestrator that calls helper functions, maintaining readability and single responsibility.
3. **Move detailed logic to helpers** - Complex logic, nested conditionals, and detailed implementations should be moved to helper functions.
4. **Re-run quality gate** - After extraction, run the full quality gate (`execute_pre_commit_checks(checks=["quality"])`) to verify violations are resolved.

### General Guidelines

- **Naming convention**: Always use `*_helpers.py` suffix for helper modules (e.g., `phase4_metadata_helpers.py`, `session_helpers.py`, `validation_helpers.py`).
- **Cohesive extraction**: Extract related functions together; avoid creating many small helper modules with single functions.
- **Test coverage**: Maintain or improve test coverage when extracting; do not reduce coverage.
- **Import organization**: Keep imports clean and organized; update `__all__` exports if used.
- **Documentation**: Update docstrings and comments to reflect the new structure.

**MANDATORY**: This pattern MUST be applied whenever file size or function length violations are detected. Do not proceed with implementation or commit until violations are resolved using this pattern.

## Private Constants Organization (ENFORCED)

1. **Private constants MUST be defined at file level**, at the bottom of the file.
2. **Private constants MUST NOT be defined inside type definitions** (classes, structs, enums).
3. **Constants used within single type** MAY be defined at file level.
4. **CI MUST fail** if private constants are defined inside type definitions.

## Private Helper Functions Organization (ENFORCED)

1. **Pure helpers at file level** - Private helper functions that don't depend on instance state MUST be defined at file level, at the bottom of the file.
2. **State-dependent helpers** - Private helper functions that depend on instance state SHOULD remain inside the type definition.
3. **CI MUST fail** if pure helper functions are unnecessarily defined inside type definitions.

## Shared Helper Re-exports (MANDATORY)

- When re-exporting shared helper functions, alias imports and call the aliased symbol to avoid accidental self-recursion (e.g., wrap `_normalize_source_path_impl` instead of calling the wrapper name).

## Dependency Injection Mandate (ENFORCED)

1. **All external dependencies MUST be injected** via initialisers or protocol conformances.
2. **NO global state or singletons** in production code. Legacy code should be progressively refactored.
3. **Constructor injection preferred** - Property injection only when circular dependencies make constructor injection impossible.

## Unit-Testing Requirements (ENFORCED)

1. **Unit tests for all critical business logic** and every public API surface.
2. **AAA pattern** - Tests MUST follow Arrange-Act-Assert structure with descriptive, behaviour-focused names (e.g., `test_viewModelEmitsError_whenRepositoryFails()`).
3. **Toggleable behaviours** - Tests SHOULD verify each toggle state.
4. **CI MUST run test suite** on every merge request/pull request and block if failures occur.
5. **Test renaming** - When updating an existing test, ALWAYS verify function name accurately reflects new behaviour; rename accordingly.

## Enforcement & CI Integration (MANDATORY)

1. **Memory Bank sync validation** - CI job validates memory bank files exist and are consistent.
2. **Rule conformance enforcement** - When a new rule is added or modified, entire codebase **MUST** be reviewed and updated to conform. CI must fail if violations remain.

## Architectural Boundaries (ENFORCED)

### Layering (MANDATORY)

- **Clear module boundaries** - e.g., Core, Plugins, Documentation, Search
- **Dependencies flow inward** - Server → Core → Plugins
- **Cross-layer calls** - Must go through defined interfaces

### Public Surface (ENFORCED)

- **Minimize public APIs** - Review public/open declarations during code review for necessity and stability
- **Deprecation policy** - When changing public APIs, add deprecation annotations and migration guidance. Remove deprecated APIs after at least one minor release

### Cross-Module Visibility (ENFORCED)

- **Cross-module symbols MUST be public** - Any symbol (class, function, method, constant) that is used outside its defining module MUST NOT be private (no underscore prefix)
- **Private symbols are module-internal only** - Private symbols (with `_` prefix) MUST only be used within the same module where they are defined
- **Detection**: If a private symbol is accessed from another module (e.g., in tests, other packages), it MUST be made public by removing the underscore prefix
- **NEVER use type-checker suppressions** - It is FORBIDDEN to use `# pyright: reportPrivateUsage=false`, `# pyright: ignore[reportPrivateUsage]`, `# type: ignore[reportPrivateUsage]`, or any similar suppression comments. These are BLOCKED and MUST be removed. The ONLY correct fix is to make the symbol public.
- **Renaming requirement**: When making a symbol public, rename it everywhere:
  - Symbol definition (remove `_` prefix)
  - All internal calls within the defining module
  - All external usages (tests, other modules)
- **Remove ignore comments**: After making a symbol public, remove any `# pyright: ignore[reportPrivateUsage]` or similar type-checker ignore comments
- **CI MUST fail** if private symbols are accessed across module boundaries or if suppression comments are found

## Plan Completion Checklist (ENFORCED)

When completing any plan, the following checklist MUST be followed in order:

1. **Code formatting** - Run formatting tools:
   - Execute `./.venv/bin/black .` and `./.venv/bin/isort .`
   - Verify formatting completes successfully with no errors or warnings
   - Fix any formatting issues if they occur
   - Verify no files were left in inconsistent state

2. **Test execution** - Run test suite:
   - Execute `./.venv/bin/pytest --session-timeout=300` (pytest-timeout configured in pytest.ini: 10s per test, 300s session timeout)
   - Ensure 100% pass rate for all executable tests (zero failures)
   - Investigate and fix any failures before proceeding

3. **Memory bank update** - Update memory bank files:
   - Execute Cursor command: `update-memory-bank`
   - **activeContext.md**: Add summaries of **completed** work only (do not add in-progress or future work here)
   - **progress.md**: Update with current achievements and progress
   - **roadmap.md**: Keep only future/upcoming work; mark completed items complete and add their summary to activeContext, then remove or archive from roadmap so completed work lives only in activeContext
   - Ensure consistency and no overlap between activeContext (completed) and roadmap (future/upcoming)
   - **MANDATORY**: Run `validate_links()` after updating memory bank files
   - Fix any broken links found

4. **Roadmap update** - Update roadmap.md:
   - **roadmap.md** holds future/upcoming work only
   - For completed work: add summary to activeContext.md, then mark complete or remove from roadmap.md (do not duplicate in both)
   - Add new roadmap items only for new future work
   - Ensure roadmap does not list completed work as active; completed work belongs in activeContext.md
   - **MANDATORY**: Run `validate_links(file_name="roadmap.md")` after updating
   - Fix any broken links found

5. **Plan archival** - Archive completed plans:
   - Resolve the plans directory path via `get_structure_info()` → `structure_info.paths.plans` (and archive subdirectory, e.g. `structure_info.paths.plans_archived` or `plans/archive/PhaseX/MilestoneY`).
   - Check the plans directory for completed plan files; move them to the plans archive directory matching the plan's type:
     - **Phase plans** (`phase-X-*.md`): Archive to `plans/archive/PhaseX/`
     - **Investigation plans** (`phase-investigate-*.md`): Archive to `plans/archive/Investigations/YYYY-MM-DD/` (use completion date or creation date from filename/content)
     - **Session optimization plans** (`session-optimization-*.md`): Archive to `plans/archive/SessionOptimization/`
   - Create archive directory structure if it doesn't exist.
   - Update plan status to "archived" if not already done
   - Ensure no active plans remain in the plans directory
   - **CRITICAL**: Plan files MUST be archived in the appropriate archive subdirectory, never left in the active plans directory
   - **MANDATORY**: After moving files, update all links in memory bank files to point to new archive location
   - **MANDATORY**: Run `validate_links()` to verify all links are valid after archival
   - Fix any broken links found

**VIOLATION**: Completing a plan without following this checklist is a CRITICAL violation that blocks proper plan closure.

## CI Quality Gates (MANDATORY)

### Static Analysis (ENFORCED)

- **Compiler warnings as errors** - Enable in CI
- **TODO/FIXME markers** - CI job fails on new markers in production sources

### Performance Budgets (ENFORCED)

- **Performance baselines** - Keep for known hot paths
- **CI flags regressions** - Beyond agreed threshold

## See Also

- [coding-standards.mdc](coding-standards.mdc) - Core coding standards and file organization requirements
- [one-public-type-per-file.mdc](one-public-type-per-file.mdc) - One public type per file requirement
- [testing-standards.mdc](testing-standards.mdc) - Testing requirements for public APIs
- [memory-bank-workflow.mdc](memory-bank-workflow.mdc) - Memory bank maintenance procedures

## Violations (BLOCKED)

- ❌ Files exceeding 400 lines (production code)
- ❌ Functions exceeding 30 lines (logical lines)
- ❌ Multiple public types per file
- ❌ Private constants inside type definitions
- ❌ Pure helpers unnecessarily inside type definitions
- ❌ Global state or singletons in production code
- ❌ Public APIs without tests
- ❌ Unsynchronized Memory Bank files
- ❌ Private symbols accessed across module boundaries
