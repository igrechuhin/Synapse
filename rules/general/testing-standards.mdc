---
globs: tests/**
alwaysApply: false
---

# Testing Standards (MANDATORY)

**ENFORCEMENT**: CI MUST fail on violations. Applies to all test files and to any project/language/code. For language-specific details (e.g. pytest, fixtures, async), see the language-specific testing rules (e.g. Python: `python-testing-standards.mdc`).

## Core Principles

- **AAA required**: Arrange-Act-Assert structure in every test.
- **Deterministic**: No flakiness; avoid time-based sleeps and randomness without seeding.
- **Performance**: Individual tests complete in <10s; suites stay lean.
- **Coverage**: Minimum 90% coverage required (MANDATORY - NO EXCEPTIONS).
  - New code paths must be covered; critical logic needs edge/error cases.
  - "Pre-existing condition" is NOT a valid excuse for low coverage.
  - Coverage threshold failures MUST be fixed before commit.

## Coverage Expectations for Consolidated Tools

For consolidated tools using handler dispatch patterns (e.g., `query_memory_bank`, `query_usage`):

- **90%+ coverage is acceptable** for consolidated tools with handler dispatch
- **95%+ coverage is ideal** but may require integration tests
- **Import statements inside handlers** are covered in real usage scenarios but may not appear in mocked unit tests
- **Mocked unit tests** typically achieve 80-90% coverage due to handler imports not being executed
- **Integration tests** can achieve 95%+ coverage by calling handlers directly

**Example**: Phase 50 consolidated tools achieved 90.13% average coverage (`query_memory_bank_operations`: 80.26%, `query_usage_operations`: 100%). The coverage gap in `query_memory_bank_operations` is due to import statements inside handler functions that are only executed when handlers are called (not when mocked). This is expected behavior and acceptable.

**When to use integration tests**:

- To achieve 95%+ coverage on consolidated tools
- To test handler dispatch patterns end-to-end
- To verify import statements inside handlers are executed

**When mocked unit tests are sufficient**:

- 80-90% coverage is acceptable for consolidated tools
- Testing individual handler logic in isolation
- Fast test execution is prioritized

## Edge Cases (MANDATORY - ALL PROJECTS/LANGUAGES)

When adding tests, **always ensure to cover all edge cases**. This applies to any project, language, or codebase.

- **Boundary conditions**: Min/max values, empty collections, zero, null/nil/None, single-element lists, exact thresholds.
- **Error handling**: Invalid inputs, malformed data, missing required fields, wrong types, out-of-range values.
- **Empty and degenerate states**: Empty strings, empty arrays, no-op inputs, identity cases.
- **Success and failure paths**: Both happy path and every documented error path must have tests.
- **Integration edge cases**: Timeouts, partial failures, concurrent access, resource exhaustion where relevant.

Do not limit tests to the happy path; edge-case coverage is mandatory for new and modified behavior.

## Skips and Marks

- Skips must include explicit reason and issue/ticket reference.
- Do not use broad `xfail` without a linked defect and a removal plan.
- No unconditional skips for entire modules; scope skips narrowly.

## Fixtures and Data

- Reuse shared fixtures (e.g. shared setup module per framework); avoid duplicated setup.
- Isolate state between tests; clean up external resources.
- Prefer factories/builders over ad-hoc data for complex payloads.

## File Watcher and OS Observer Tests

- **Mock observer instances**: Tests for file watchers or other OS-level observers MUST patch the observer implementation and verify interactions (start, stop, schedule); do not rely on real observer threads.
- **Rationale**: Real observer threads are unstable under test timeouts and slow; mocking keeps tests deterministic and fast. (Python: see `python-testing-standards.mdc` for watchdog/Observer pattern.)

## Async Tests

- Use the framework's async test marker or plugin for async tests.
- Avoid blocking calls inside async tests; offload with executors when needed.

## Assertions

- Assert behavior, not implementation details; include clear failure messages for complex checks.
- Validate both success and failure/error paths for public APIs.

## Testing Private/Internal Functions (FORBIDDEN)

**CRITICAL**: Private/internal functions (implementation details) MUST NOT be tested directly.

**FORBIDDEN:**

- ❌ Importing private/internal functions in test files
- ❌ Using type checker suppressions or workarounds to test private functions
- ❌ Testing private implementation details directly
- ❌ Bypassing encapsulation to test internal behavior

**REQUIRED:**

- ✅ Test private/internal functions through public interface only
- ✅ If private function needs direct testing, make it public or extract to separate module
- ✅ Test behavior, not implementation details
- ✅ Verify functionality through public API contracts
